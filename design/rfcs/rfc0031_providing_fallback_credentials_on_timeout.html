<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0031: Providing Fallback Credentials on Timeout - Smithy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">4.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">4.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">4.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">4.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">4.4.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../client/overview.html"><strong aria-hidden="true">5.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client/orchestrator.html"><strong aria-hidden="true">5.1.</strong> What is the 'orchestrator' and why does it exist?</a></li><li class="chapter-item expanded "><a href="../client/identity_and_auth.html"><strong aria-hidden="true">5.2.</strong> Identity and Auth</a></li><li class="chapter-item expanded "><a href="../client/detailed_error_explanations.html"><strong aria-hidden="true">5.3.</strong> Detailed error explanations</a></li></ol></li><li class="chapter-item expanded "><a href="../server/overview.html"><strong aria-hidden="true">6.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/middleware.html"><strong aria-hidden="true">6.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="../server/instrumentation.html"><strong aria-hidden="true">6.2.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../server/from_parts.html"><strong aria-hidden="true">6.3.</strong> Accessing Un-modelled Data</a></li><li class="chapter-item expanded "><a href="../server/anatomy.html"><strong aria-hidden="true">6.4.</strong> The Anatomy of a Service</a></li><li class="chapter-item expanded "><a href="../server/code_generation.html"><strong aria-hidden="true">6.5.</strong> Generating Common Service Code</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">7.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">7.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">7.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">7.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">7.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">7.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">7.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">7.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">7.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">7.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">7.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">7.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">7.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">7.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">7.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">7.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">7.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">7.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">7.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">7.19.</strong> RFC-0019: Event Streams Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0020_service_builder.html"><strong aria-hidden="true">7.20.</strong> RFC-0020: Service Builder Improvements</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0021_dependency_versions.html"><strong aria-hidden="true">7.21.</strong> RFC-0021: Dependency Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0022_error_context_and_compatibility.html"><strong aria-hidden="true">7.22.</strong> RFC-0022: Error Context and Compatibility</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0023_refine_builder.html"><strong aria-hidden="true">7.23.</strong> RFC-0023: Evolving the new service builder API</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0024_request_id.html"><strong aria-hidden="true">7.24.</strong> RFC-0024: RequestID</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0025_constraint_traits.html"><strong aria-hidden="true">7.25.</strong> RFC-0025: Constraint traits</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0026_client_crate_organization.html"><strong aria-hidden="true">7.26.</strong> RFC-0026: Client Crate Organization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0027_endpoints_20.html"><strong aria-hidden="true">7.27.</strong> RFC-0027: Endpoints 2.0</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0028_sdk_credential_cache_type_safety.html"><strong aria-hidden="true">7.28.</strong> RFC-0028: SDK Credential Cache Type Safety</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0029_new_home_for_cred_types.html"><strong aria-hidden="true">7.29.</strong> RFC-0029: Finding New Home for Credential Types</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0030_serialization_and_deserialization.html"><strong aria-hidden="true">7.30.</strong> RFC-0030: Serialization And Deserialization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0031_providing_fallback_credentials_on_timeout.html" class="active"><strong aria-hidden="true">7.31.</strong> RFC-0031: Providing Fallback Credentials on Timeout</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0032_better_constraint_violations.html"><strong aria-hidden="true">7.32.</strong> RFC-0032: Better Constraint Violations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0033_improve_sdk_request_id_access.html"><strong aria-hidden="true">7.33.</strong> RFC-0033: Improving access to request IDs in SDK clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0034_smithy_orchestrator.html"><strong aria-hidden="true">7.34.</strong> RFC-0034: Smithy Orchestrator</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0035_collection_defaults.html"><strong aria-hidden="true">7.35.</strong> RFC-0035: Collection Defaults</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0036_http_dep_elimination.html"><strong aria-hidden="true">7.36.</strong> RFC-0036: HTTP Dependency Exposure</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0037_http_wrapper.html"><strong aria-hidden="true">7.37.</strong> RFC-0037: The HTTP Wrapper</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0038_retry_classifier_customization.html"><strong aria-hidden="true">7.38.</strong> RFC-0038: User-configurable retry classification</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0039_forward_compatible_errors.html"><strong aria-hidden="true">7.39.</strong> RFC-0039: Forward Compatible Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0040_behavior_versions.html"><strong aria-hidden="true">7.40.</strong> RFC-0040: Behavior Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0041_improve_client_error_ergonomics.html"><strong aria-hidden="true">7.41.</strong> RFC-0041: Improve client error ergonomics</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0042_file_per_change_changelog.html"><strong aria-hidden="true">7.42.</strong> RFC-0042: File-per-change changelog</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0043_identity_cache_partitions.html"><strong aria-hidden="true">7.43.</strong> RFC-0043: Identity Cache Partitions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0044_env_defined_service_config.html"><strong aria-hidden="true">7.44.</strong> RFC-0044: Environment-defined service configuration</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">8.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">8.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smithy Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-providing-fallback-credentials-on-external-timeout"><a class="header" href="#rfc-providing-fallback-credentials-on-external-timeout">RFC: Providing fallback credentials on external timeout</a></h1>
<blockquote>
<p>Status: Implemented in <a href="https://github.com/smithy-lang/smithy-rs/pull/2246">smithy-rs#2246</a></p>
<p>Applies to: client</p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="#changes-checklist">Changes Checklist</a> section.</p>
<p>This RFC proposes a fallback mechanism for credentials providers on external timeout (see the <a href="#terminology">Terminology</a> section), allowing them to continue serving (possibly expired) credentials for the sake of overall reliability of the intended service; The IMDS credentials provider is an example that must fulfill such a requirement to support static stability.</p>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<ul>
<li>External timeout: The name of the timeout that occurs when a duration elapses before an async call to <code>provide_credentials</code> returns. In this case, <code>provide_credentials</code> returns no credentials.</li>
<li>Internal timeout: The name of the timeout that occurs when a duration elapses before an async call to some function, inside the implementation of <code>provide_credentials</code>, returns. Examples include connection timeouts, TLS negotiation timeouts, and HTTP request timeouts. Implementations of <code>provide_credentials</code> may handle these failures at their own discretion e.g. by returning <em>(possibly expired)</em> credentials or a <code>CredentialsError</code>.</li>
<li>Static stability: Continued availability of a service in the face of impaired dependencies.</li>
</ul>
<h2 id="assumption"><a class="header" href="#assumption">Assumption</a></h2>
<p>This RFC is concerned only with external timeouts, as the cost of poor API design is much higher in this case than for internal timeouts. The former will affect a public trait implemented by all credentials providers whereas the latter can be handled locally by individual credentials providers without affecting one another.</p>
<h2 id="problem"><a class="header" href="#problem">Problem</a></h2>
<p>We have mentioned static stability. Supporting it calls for the following functional requirement, among others:</p>
<ul>
<li>REQ 1: Once a credentials provider has served credentials, it should continue serving them in the event of a timeout (whether internal or external) while obtaining refreshed credentials.</li>
</ul>
<p>Today, we have the following trait method to obtain credentials:</p>
<pre><code class="language-rust ignore">fn provide_credentials&lt;'a&gt;(&amp;'a self) -&gt; future::ProvideCredentials&lt;'a&gt;
where
    Self: 'a,</code></pre>
<p>This method returns a future, which can be raced against a timeout future as demonstrated by the following code snippet from <code>LazyCredentialsCache</code>:</p>
<pre><code class="language-rust ignore">let timeout_future = self.sleeper.sleep(self.load_timeout); // by default self.load_timeout is 5 seconds.
// --snip--
let future = Timeout::new(provider.provide_credentials(), timeout_future);
let result = cache
   .get_or_load(|| async move {
        let credentials = future.await.map_err(|_err| {
            CredentialsError::provider_timed_out(load_timeout)
        })??;
        // --snip--
    }).await;
// --snip--</code></pre>
<p>This creates an external timeout for <code>provide_credentials</code>. If <code>timeout_future</code> wins the race, a future for <code>provide_credentials</code> gets dropped, <code>timeout_future</code> returns an error, and the error is mapped to <code>CredentialsError::ProviderTimedOut</code> and returned. This makes it impossible for the variable <code>provider</code> above to serve credentials as stated in REQ 1.</p>
<p>A more complex use case involves <code>CredentialsProviderChain</code>. It is a manifestation of the chain of responsibility pattern and keeps calling the <code>provide_credentials</code> method on each credentials provider down the chain until credentials are returned by one of them. In addition to REQ 1, we have the following functional requirement with respect to <code>CredentialsProviderChain</code>:</p>
<ul>
<li>REQ 2: Once a credentials provider in the chain has returned credentials, it should continue serving them even in the event of a timeout (whether internal or external) without falling back to another credentials provider.</li>
</ul>
<p>Referring back to the code snippet above, we analyze two relevant cases (and suppose provider 2 below must meet REQ 1 and REQ 2 in each case):</p>
<p><strong>Case 1:</strong> Provider 2 successfully loaded credentials but later failed to do so because an external timeout kicked in.</p>
<p align="center">
<img width="750" alt="chain-provider-ext-timeout-1" src="https://user-images.githubusercontent.com/15333866/212421638-d08e4821-2dbe-497f-82c5-c78aab8acbe9.png">
</p>
<p>The figure above illustrates an example. This <code>CredentialsProviderChain</code> consists of three credentials providers. When <code>CredentialsProviderChain::provide_credentials</code> is called, provider 1's <code>provide_credentials</code> is called but does not find credentials so passes the torch to provider 2, which in turn successfully loads credentials and returns them. The next time the method is called, provider 1 does not find credentials but neither does provider 2 this time, because an external timeout by <code>timeout_future</code> given to the whole chain kicked in and the future is dropped while provider 2's <code>provide_credentials</code> was running. Given the functional requirements, provider 2 should return the previously available credentials but today the code snippet from <code>LazyCredentialsCache</code> returns a <code>CredentialsError::ProviderTimedOut</code> instead.</p>
<p><strong>Case 2:</strong> Provider 2 successfully loaded credentials but later was not reached because its preceding provider was still running when an external timeout kicked in.</p>
<p align="center">
<img width="750" alt="chain-provider-ext-timeout-2" src="https://user-images.githubusercontent.com/15333866/212421712-8c6eab11-a0c1-4229-8ba3-67b0bb6056e7.png">
</p>
<p>The figure above illustrates an example with the same setting as the previous figure. Again, when <code>CredentialsProviderChain::provide_credentials</code> is called the first time, provider 1 does not find credentials but provider 2 does. The next time the method is called, provider 1 is still executing <code>provide_credentials</code> and then an external timeout by <code>timeout_future</code> kicked in. Consequently, the execution of <code>CredentialsProviderChain::provide_credentials</code> has been terminated. Given the functional requirements, provider 2 should return the previously available credentials but today the code snippet from <code>LazyCredentialsCache</code> returns <code>CredentialsError::ProviderTimedOut</code> instead.</p>
<h2 id="proposal"><a class="header" href="#proposal">Proposal</a></h2>
<p>To address the problem in the previous section, we propose to add a new method to the <code>ProvideCredentials</code> trait called <code>fallback_on_interrupt</code>. This method allows credentials providers to have a fallback mechanism on an external timeout and to serve credentials to users if needed. There are two options as to how it is implemented, either as a synchronous primitive or as an asynchronous primitive.</p>
<h4 id="option-a-synchronous-primitive"><a class="header" href="#option-a-synchronous-primitive">Option A: Synchronous primitive</a></h4>
<pre><code class="language-rust ignore">pub trait ProvideCredentials: Send + Sync + std::fmt::Debug {
    // --snip--

    fn fallback_on_interrupt(&amp;self) -&gt; Option&lt;Credentials&gt; {
        None
    }
}</code></pre>
<ul>
<li>:+1: Users can be guided to use only synchronous primitives when implementing <code>fallback_on_interrupt</code>.</li>
<li>:-1: It cannot support cases where fallback credentials are asynchronously retrieved.</li>
<li>:-1: It may turn into a blocking operation if it takes longer than it should.</li>
</ul>
<h4 id="option-b-asynchronous-primitive"><a class="header" href="#option-b-asynchronous-primitive">Option B: Asynchronous primitive</a></h4>
<pre><code class="language-rust ignore">mod future {
    // --snip--

    // This cannot use `OnlyReady` in place of `BoxFuture` because
    // when a chain of credentials providers implements its own
    // `fallback_on_interrupt`, it needs to await fallback credentials
    // in its inner providers. Thus, `BoxFuture` is required.
    pub struct FallbackOnInterrupt&lt;'a&gt;(NowOrLater&lt;Option&lt;Credentials&gt;, BoxFuture&lt;'a, Option&lt;Credentials&gt;&gt;&gt;);

    // impls for FallbackOnInterrupt similar to those for the ProvideCredentials future newtype
}

pub trait ProvideCredentials: Send + Sync + std::fmt::Debug {
    // --snip--

    fn fallback_on_interrupt&lt;'a&gt;(&amp;'a self) -&gt; future::FallbackOnInterrupt&lt;'a&gt; {
        future::FallbackOnInterrupt::ready(None)
    }
}</code></pre>
<ul>
<li>:+1: It is async from the beginning, so less likely to introduce a breaking change.</li>
<li>:-1: We may have to consider yet another timeout for <code>fallback_on_interrupt</code> itself.</li>
</ul>
<p>Option A cannot be reversible in the future if we are to support the use case for asynchronously retrieving the fallback credentials, whereas option B allows us to continue supporting both ready and pending futures when retrieving the fallback credentials. However, <code>fallback_on_interrupt</code> is supposed to return credentials that have been set aside in case <code>provide_credentials</code> is timed out. To express that intent, we choose option A and document that users should NOT go fetch new credentials in <code>fallback_on_interrupt</code>.</p>
<p>The user experience for the code snippet in question will look like this once this proposal is implemented:</p>
<pre><code class="language-rust ignore">let timeout_future = self.sleeper.sleep(self.load_timeout); // by default self.load_timeout is 5 seconds.
// --snip--
let future = Timeout::new(provider.provide_credentials(), timeout_future);
let result = cache
    .get_or_load(|| {
        async move {
           let credentials = match future.await {
                Ok(creds) =&gt; creds?,
                Err(_err) =&gt; match provider.fallback_on_interrupt() { // can provide fallback credentials
                    Some(creds) =&gt; creds,
                    None =&gt; return Err(CredentialsError::provider_timed_out(load_timeout)),
                }
            };
            // --snip--
        }
    }).await;
// --snip--</code></pre>
<h2 id="how-to-actually-implement-this-rfc"><a class="header" href="#how-to-actually-implement-this-rfc">How to actually implement this RFC</a></h2>
<p>Almost all credentials providers do not have to implement their own <code>fallback_on_interrupt</code> except for <code>CredentialsProviderChain</code> (<code>ImdsCredentialsProvider</code> also needs to implement <code>fallback_on_interrupt</code> when we are adding static stability support to it but that is outside the scope of this RFC).</p>
<p>Considering the two cases we analyzed above, implementing <code>CredentialsProviderChain::fallback_on_interrupt</code> is not so straightforward. Keeping track of whose turn in the chain it is to call <code>provide_credentials</code> when an external timeout has occurred is a challenging task. Even if we figured it out, that would still not satisfy <code>Case 2</code> above, because it was provider 1 that was actively running when the external timeout kicked in, but the chain should return credentials from provider 2, not from provider 1.</p>
<p>With that in mind, consider instead the following approach:</p>
<pre><code class="language-rust ignore">impl ProvideCredentials for CredentialsProviderChain {
    // --snip--

    fn fallback_on_interrupt(&amp;self) -&gt; Option&lt;Credentials&gt; { {
        for (_, provider) in &amp;self.providers {
            match provider.fallback_on_interrupt() {
                creds @ Some(_) =&gt; return creds,
                None =&gt; {}
            }
        }
        None
    }
}</code></pre>
<p><code>CredentialsProviderChain::fallback_on_interrupt</code> will invoke each provider's <code>fallback_on_interrupt</code> method until credentials are returned by one of them. It ensures that the updated code snippet for <code>LazyCredentialsCache</code> can return credentials from provider 2 in both <code>Case 1</code> and <code>Case 2</code>. Even if <code>timeout_future</code> wins the race, the execution subsequently calls <code>provider.fallback_on_interrupt()</code> to obtain fallback credentials from provider 2, assuming provider 2's <code>fallback_on_interrupt</code> is implemented to return fallback credentials accordingly.</p>
<p>The downside of this simple approach is that the behavior is not clear if more than one credentials provider in the chain can return credentials from their <code>fallback_on_interrupt</code>. Note, however, that it is the exception rather than the norm for a provider's <code>fallback_on_interrupt</code> to return fallback credentials, at least at the time of writing (01/13/2023). The fact that it returns fallback credentials means that the provider successfully loaded credentials at least once, and it usually continues serving credentials on subsequent calls to <code>provide_credentials</code>.</p>
<p>Should we have more than one provider in the chain that can potentially return fallback credentials from <code>fallback_on_interrupt</code>, we could configure the behavior of <code>CredentialsProviderChain</code> managing in what order and how each <code>fallback_on_interrupt</code> should be executed. See the <a href="#possible-enhancement">Possible enhancement
</a> section for more details. The use case described there is an extreme edge case, but it's worth exploring what options are available to us with the proposed design.</p>
<h2 id="alternative"><a class="header" href="#alternative">Alternative</a></h2>
<p>In this section, we will describe an alternative approach that we ended up dismissing as unworkable.</p>
<p>Instead of <code>fallback_on_interrupt</code>, we considered the following method to be added to the <code>ProvideCredentials</code> trait:</p>
<pre><code class="language-rust ignore">pub trait ProvideCredentials: Send + Sync + std::fmt::Debug {
    // --snip--

    /// Returns a future that provides credentials within the given `timeout`.
    ///
    /// The default implementation races `provide_credentials` against
    /// a timeout future created from `timeout`.
    fn provide_credentials_with_timeout&lt;'a&gt;(
        &amp;'a self,
        sleeper: Arc&lt;dyn AsyncSleep&gt;,
        timeout: Duration,
    ) -&gt; future::ProvideCredentials&lt;'a&gt;
    where
        Self: 'a,
    {
        let timeout_future = sleeper.sleep(timeout);
        let future = Timeout::new(self.provide_credentials(), timeout_future);
        future::ProvideCredentials::new(async move {
            let credentials = future
                .await
                .map_err(|_err| CredentialsError::provider_timed_out(timeout))?;
            credentials
        })
    }</code></pre>
<p><code>provide_credentials_with_timeout</code> encapsulated the timeout race and allowed users to specify how long the external timeout for <code>provide_credentials</code> would be. The code snippet from <code>LazyCredentialsCache</code> then looked like</p>
<pre><code class="language-rust ignore">let sleeper = Arc::clone(&amp;self.sleeper);
let load_timeout = self.load_timeout; // by default self.load_timeout is 5 seconds.
// --snip--
let result = cache
    .get_or_load(|| {
        async move {
            let credentials = provider
                .provide_credentials_with_timeout(sleeper, load_timeout)
                .await?;
            // --snip--
        }
    }).await;
// --snip--</code></pre>
<p>However, implementing <code>CredentialsProviderChain::provide_credentials_with_timeout</code> quickly ran into the following problem:</p>
<pre><code class="language-rust ignore">impl ProvideCredentials for CredentialsProviderChain {
    // --snip--

    fn provide_credentials_with_timeout&lt;'a&gt;(
        &amp;'a self,
        sleeper: Arc&lt;dyn AsyncSleep&gt;,
        timeout: Duration,
    ) -&gt; future::ProvideCredentials&lt;'a&gt;
    where
        Self: 'a,
    {
        future::ProvideCredentials::new(self.credentials_with_timeout(sleeper, timeout))
    }
}

impl CredentialsProviderChain {
    // --snip--

    async fn credentials_with_timeout(
        &amp;self,
        sleeper: Arc&lt;dyn AsyncSleep&gt;,
        timeout: Duration,
    ) -&gt; provider::Result {
        for (_, provider) in &amp;self.providers {
            match provider
                .provide_credentials_with_timeout(Arc::clone(&amp;sleeper), /* how do we calculate timeout for each provider ? */)
                .await
            {
                Ok(credentials) =&gt; {
                    return Ok(credentials);
                }
                Err(CredentialsError::ProviderTimedOut(_)) =&gt; {
                    // --snip--
                }
                Err(err) =&gt; {
                   // --snip--
                }
           }
        }
        Err(CredentialsError::provider_timed_out(timeout))
    }</code></pre>
<p>There are mainly two problems with this approach. The first problem is that as shown above, there is no sensible way to calculate a timeout for each provider in the chain. The second problem is that exposing a parameter like <code>timeout</code> at a public trait's level is giving too much control to users; delegating overall timeout to the individual provider means each provider has to get it right.</p>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Add <code>fallback_on_interrupt</code> method to the <code>ProvideCredentials</code> trait with the default implementation</li>
<li><input disabled="" type="checkbox"/>
Implement <code>CredentialsProviderChain::fallback_on_interrupt</code></li>
<li><input disabled="" type="checkbox"/>
Implement <code>DefaultCredentialsChain::fallback_on_interrupt</code></li>
<li><input disabled="" type="checkbox"/>
Add unit tests for <code>Case 1</code> and <code>Case 2</code></li>
</ul>
<h2 id="possible-enhancement"><a class="header" href="#possible-enhancement">Possible enhancement</a></h2>
<p>We will describe how to customize the behavior for <code>CredentialsProviderChain::fallback_on_interrupt</code>. We are only demonstrating how much the proposed design can be extended and currently do not have concrete use cases to implement using what we present in this section.</p>
<p>As described in the <a href="#proposal">Proposal</a> section, <code>CredentialsProviderChain::fallback_on_interrupt</code> traverses the chain from the head to the tail and returns the first fallback credentials found. This precedence policy works most of the time, but when we have more than one provider in the chain that can potentially return fallback credentials, it could break in the following edge case (we are still basing our discussion on the code snippet from <code>LazyCredentialsCache</code> but forget REQ 1 and REQ 2 for the sake of simplicity).</p>
<p align="center">
<img width="800" alt="fallback_on_interrupt_appendix excalidraw" src="https://user-images.githubusercontent.com/15333866/213618808-d19892d8-5c83-4039-9940-280dcd2a8cf1.png">
</p>
<p>During the first call to <code>CredentialsProviderChain::provide_credentials</code>, provider 1 fails to load credentials, maybe due to an internal timeout, and then provider 2 succeeds in loading its credentials (call them credentials 2) and internally stores them for <code>Provider2::fallback_on_interrupt</code> to return them subsequently. During the second call, provider 1 succeeds in loading credentials (call them credentials 1) and internally stores them for <code>Provider1::fallback_on_interrupt</code> to return them subsequently. Suppose, however, that credentials 1's expiry is earlier than credentials 2's expiry. Finally, during the third call, <code>CredentialsProviderChain::provide_credentials</code> did not complete due to an external timeout. <code>CredentialsProviderChain::fallback_on_interrupt</code> then returns credentials 1, when it should return credentials 2 whose expiry is later, because of the precedence policy.</p>
<p>This a case where <code>CredentialsProviderChain::fallback_on_interrupt</code> requires the recency policy for fallback credentials found in provider 1 and provider 2, not the precedence policy. The following figure shows how we can set up such a chain:</p>
<p align="center">
<img width="700" alt="heterogeneous_policies_for_fallback_on_interrupt" src="https://user-images.githubusercontent.com/15333866/213755875-ac6fddbc-0f1b-4437-af16-6e0dbe08ae04.png">
</p>
<p>The outermost chain is a <code>CredentialsProviderChain</code> and follows the precedence policy for <code>fallback_on_interrupt</code>. It contains a sub-chain that, in turn, contains provider 1 and provider 2. This sub-chain implements its own <code>fallback_on_interrupt</code> to realize the recency policy for fallback credentials found in provider 1 and provider 2. Conceptually, we have</p>
<pre><code class="language-rust ignore">pub struct FallbackRecencyChain {
    provider_chain: CredentialsProviderChain,
}

impl ProvideCredentials for FallbackRecencyChain {
    fn provide_credentials&lt;'a&gt;(&amp;'a self) -&gt; future::ProvideCredentials&lt;'a&gt;
    where
        Self: 'a,
    {
        // Can follow the precedence policy for loading credentials
        // if it chooses to do so.
    }

    fn fallback_on_interrupt(&amp;self) -&gt; Option&lt;Credentials&gt; {
        // Iterate over `self.provider_chain` and return
        // fallback credentials whose expiry is the most recent.
    }
}</code></pre>
<p>We can then compose the entire chain like so:</p>
<pre><code class="language-rust ignore">let provider_1 = /* ... */
let provider_2 = /* ... */
let provider_3 = /* ... */

let sub_chain = CredentialsProviderChain::first_try("Provider1", provider_1)
    .or_else("Provider2", provider_2);

let recency_chain = /* Create a FallbackRecencyChain with sub_chain */

let final_chain = CredentialsProviderChain::first_try("fallback_recency", recency_chain)
    .or_else("Provider3", provider_3);</code></pre>
<p>The <code>fallback_on_interrupt</code> method on <code>final_chain</code> still traverses from the head to the tail, but once it hits <code>recency_chain</code>, <code>fallback_on_interrupt</code> on <code>recency_chain</code> respects the expiry of fallback credentials found in its inner providers.</p>
<p>What we have presented in this section can be generalized thanks to chain composability. We could have different sub-chains, each implementing its own policy for <code>fallback_on_interrupt</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rfcs/rfc0030_serialization_and_deserialization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rfcs/rfc0032_better_constraint_violations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rfcs/rfc0030_serialization_and_deserialization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rfcs/rfc0032_better_constraint_violations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../static/mermaid.min.js"></script>
        <script src="../static/mermaid-init.js"></script>


    </div>
    </body>
</html>
