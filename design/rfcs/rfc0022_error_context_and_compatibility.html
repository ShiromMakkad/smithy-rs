<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0022: Error Context and Compatibility - Smithy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">4.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">4.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">4.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">4.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">4.4.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../client/overview.html"><strong aria-hidden="true">5.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client/orchestrator.html"><strong aria-hidden="true">5.1.</strong> What is the 'orchestrator' and why does it exist?</a></li><li class="chapter-item expanded "><a href="../client/identity_and_auth.html"><strong aria-hidden="true">5.2.</strong> Identity and Auth</a></li><li class="chapter-item expanded "><a href="../client/detailed_error_explanations.html"><strong aria-hidden="true">5.3.</strong> Detailed error explanations</a></li></ol></li><li class="chapter-item expanded "><a href="../server/overview.html"><strong aria-hidden="true">6.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/middleware.html"><strong aria-hidden="true">6.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="../server/instrumentation.html"><strong aria-hidden="true">6.2.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../server/from_parts.html"><strong aria-hidden="true">6.3.</strong> Accessing Un-modelled Data</a></li><li class="chapter-item expanded "><a href="../server/anatomy.html"><strong aria-hidden="true">6.4.</strong> The Anatomy of a Service</a></li><li class="chapter-item expanded "><a href="../server/code_generation.html"><strong aria-hidden="true">6.5.</strong> Generating Common Service Code</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">7.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">7.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">7.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">7.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">7.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">7.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">7.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">7.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">7.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">7.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">7.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">7.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">7.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">7.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">7.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">7.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">7.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">7.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">7.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">7.19.</strong> RFC-0019: Event Streams Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0020_service_builder.html"><strong aria-hidden="true">7.20.</strong> RFC-0020: Service Builder Improvements</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0021_dependency_versions.html"><strong aria-hidden="true">7.21.</strong> RFC-0021: Dependency Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0022_error_context_and_compatibility.html" class="active"><strong aria-hidden="true">7.22.</strong> RFC-0022: Error Context and Compatibility</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0023_refine_builder.html"><strong aria-hidden="true">7.23.</strong> RFC-0023: Evolving the new service builder API</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0024_request_id.html"><strong aria-hidden="true">7.24.</strong> RFC-0024: RequestID</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0025_constraint_traits.html"><strong aria-hidden="true">7.25.</strong> RFC-0025: Constraint traits</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0026_client_crate_organization.html"><strong aria-hidden="true">7.26.</strong> RFC-0026: Client Crate Organization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0027_endpoints_20.html"><strong aria-hidden="true">7.27.</strong> RFC-0027: Endpoints 2.0</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0028_sdk_credential_cache_type_safety.html"><strong aria-hidden="true">7.28.</strong> RFC-0028: SDK Credential Cache Type Safety</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0029_new_home_for_cred_types.html"><strong aria-hidden="true">7.29.</strong> RFC-0029: Finding New Home for Credential Types</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0030_serialization_and_deserialization.html"><strong aria-hidden="true">7.30.</strong> RFC-0030: Serialization And Deserialization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0031_providing_fallback_credentials_on_timeout.html"><strong aria-hidden="true">7.31.</strong> RFC-0031: Providing Fallback Credentials on Timeout</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0032_better_constraint_violations.html"><strong aria-hidden="true">7.32.</strong> RFC-0032: Better Constraint Violations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0033_improve_sdk_request_id_access.html"><strong aria-hidden="true">7.33.</strong> RFC-0033: Improving access to request IDs in SDK clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0034_smithy_orchestrator.html"><strong aria-hidden="true">7.34.</strong> RFC-0034: Smithy Orchestrator</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0035_collection_defaults.html"><strong aria-hidden="true">7.35.</strong> RFC-0035: Collection Defaults</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0036_http_dep_elimination.html"><strong aria-hidden="true">7.36.</strong> RFC-0036: HTTP Dependency Exposure</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0037_http_wrapper.html"><strong aria-hidden="true">7.37.</strong> RFC-0037: The HTTP Wrapper</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0038_retry_classifier_customization.html"><strong aria-hidden="true">7.38.</strong> RFC-0038: User-configurable retry classification</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0039_forward_compatible_errors.html"><strong aria-hidden="true">7.39.</strong> RFC-0039: Forward Compatible Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0040_behavior_versions.html"><strong aria-hidden="true">7.40.</strong> RFC-0040: Behavior Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0041_improve_client_error_ergonomics.html"><strong aria-hidden="true">7.41.</strong> RFC-0041: Improve client error ergonomics</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0042_file_per_change_changelog.html"><strong aria-hidden="true">7.42.</strong> RFC-0042: File-per-change changelog</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0043_identity_cache_partitions.html"><strong aria-hidden="true">7.43.</strong> RFC-0043: Identity Cache Partitions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0044_env_defined_service_config.html"><strong aria-hidden="true">7.44.</strong> RFC-0044: Environment-defined service configuration</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">8.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">8.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smithy Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-error-context-and-compatibility"><a class="header" href="#rfc-error-context-and-compatibility">RFC: Error Context and Compatibility</a></h1>
<blockquote>
<p>Status: Implemented</p>
<p>Applies to: Generated clients and shared rust-runtime crates</p>
</blockquote>
<p>This RFC proposes a pattern for writing Rust errors to provide consistent
error context AND forwards/backwards compatibility. The goal is to strike
a balance between these four goals:</p>
<ol>
<li>Errors are forwards compatible, and changes to errors are backwards compatible</li>
<li>Errors are idiomatic and ergonomic. It is easy to match on them and extract additional
information for cases where that's useful. The type system prevents errors from being used
incorrectly (for example, incorrectly retrieving context for a different error variant)</li>
<li>Error messages are easy to debug</li>
<li>Errors implement best practices with Rust's <code>Error</code> trait (for example, implementing the optional <code>source()</code> function where possible)</li>
</ol>
<p><em>Note:</em> This RFC is <em>not</em> about error backwards compatibility when it comes to error serialization/deserialization
for transfer over the wire. The Smithy protocols cover that aspect.</p>
<h2 id="past-approaches-in-smithy-rs"><a class="header" href="#past-approaches-in-smithy-rs">Past approaches in smithy-rs</a></h2>
<p>This section examines some examples found in <code>aws-config</code> that illustrate different problems
that this RFC will attempt to solve, and calls out what was done well, and what could be improved upon.</p>
<h3 id="case-study-invalidfullurierror"><a class="header" href="#case-study-invalidfullurierror">Case study: <code>InvalidFullUriError</code></a></h3>
<p>To start, let's examine <code>InvalidFullUriError</code> (doc comments omitted):</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
#[non_exhaustive]
pub enum InvalidFullUriError {
    #[non_exhaustive] InvalidUri(InvalidUri),
    #[non_exhaustive] NoDnsService,
    #[non_exhaustive] MissingHost,
    #[non_exhaustive] NotLoopback,
    DnsLookupFailed(io::Error),
}

impl Display for InvalidFullUriError {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            InvalidFullUriError::InvalidUri(err) =&gt; write!(f, "URI was invalid: {}", err),
            InvalidFullUriError::MissingHost =&gt; write!(f, "URI did not specify a host"),
            // ... omitted ...
        }
    }
}

impl Error for InvalidFullUriError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        match self {
            InvalidFullUriError::InvalidUri(err) =&gt; Some(err),
            InvalidFullUriError::DnsLookupFailed(err) =&gt; Some(err),
            _ =&gt; None,
        }
    }
}</code></pre>
<p>This error does a few things well:</p>
<ol>
<li>Using <code>#[non_exhaustive]</code> on the enum allows new errors to be added in the future.</li>
<li>Breaking out different error types allows for more useful error messages, potentially with error-specific context.
Customers can match on these different error variants to change their program flow, although it's not immediately
obvious if such use cases exist for this error.</li>
<li>The error cause is available through the <code>Error::source()</code> impl for variants that have a cause.</li>
</ol>
<p>However, there are also a number of things that could be improved:</p>
<ol>
<li>All tuple/struct enum members are public, and <code>InvalidUri</code> is an error from the <code>http</code> crate.
Exposing a type from another crate can potentially lock the GA SDK into a specific crate version
if breaking changes are ever made to the exposed types. In this specific case, it prevents
using alternate HTTP implementations that don't use the <code>http</code> crate.</li>
<li><code>DnsLookupFailed</code> is missing <code>#[non_exhaustive]</code>, so new members can never be added to it.</li>
<li>Use of enum tuples, even with <code>#[non_exhaustive]</code>, adds friction to evolving the API since the
tuple members cannot be named.</li>
<li>Printing the source error in the <code>Display</code> impl leads to error repetition by reporters
that examine the full source chain.</li>
<li>The <code>source()</code> impl has a <code>_</code> match arm, which means future implementers could forget to propagate
a source when adding new error variants.</li>
<li>The error source can be downcasted to <code>InvalidUri</code> type from <code>http</code> in customer code. This is
a leaky abstraction where customers can start to rely on the underlying library the SDK uses
in its implementation, and if that library is replaced/changed, it can silently break the
customer's application. <em>Note:</em> later in the RFC, I'll demonstrate why fixing this issue is not practical.</li>
</ol>
<h3 id="case-study-profileparseerror"><a class="header" href="#case-study-profileparseerror">Case study: <code>ProfileParseError</code></a></h3>
<p>Next, let's look at a much simpler error. The <code>ProfileParseError</code> is focused purely on the parsing
logic for the SDK config file:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Clone)]
pub struct ProfileParseError {
    location: Location,
    message: String,
}

impl Display for ProfileParseError {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "error parsing {} on line {}:\n  {}",
            self.location.path, self.location.line_number, self.message
        )
    }
}

impl Error for ProfileParseError {}</code></pre>
<p>What this error does well:</p>
<ul>
<li>The members are private, so <code>#[non_exhaustive]</code> isn't even necessary</li>
<li>The error is completely opaque (maximizing compatibility) while still being
debuggable thanks to the flexible messaging</li>
</ul>
<p>What could be improved:</p>
<ul>
<li>It needlessly implements <code>Clone</code>, which may prevent it from holding
an error source in the future since errors are often not <code>Clone</code>.</li>
<li>In the future, if more error variants are needed, a private inner error
kind enum could be added to change messaging, but there's not a <em>nice</em> way to
expose new variant-specific information to the customer.</li>
<li>Programmatic access to the error <code>Location</code> may be desired, but
this can be trivially added in the future without a breaking change by
adding an accessor method.</li>
</ul>
<h3 id="case-study-code-generated-client-errors"><a class="header" href="#case-study-code-generated-client-errors">Case study: code generated client errors</a></h3>
<p>The SDK currently generates errors such as the following (from S3):</p>
<pre><code class="language-rust ignore">#[non_exhaustive]
pub enum Error {
    BucketAlreadyExists(BucketAlreadyExists),
    BucketAlreadyOwnedByYou(BucketAlreadyOwnedByYou),
    InvalidObjectState(InvalidObjectState),
    NoSuchBucket(NoSuchBucket),
    NoSuchKey(NoSuchKey),
    NoSuchUpload(NoSuchUpload),
    NotFound(NotFound),
    ObjectAlreadyInActiveTierError(ObjectAlreadyInActiveTierError),
    ObjectNotInActiveTierError(ObjectNotInActiveTierError),
    Unhandled(Box&lt;dyn Error + Send + Sync + 'static&gt;),
}</code></pre>
<p>Each error variant gets its own struct, which can hold error-specific contextual information.
Except for the <code>Unhandled</code> variant, both the error enum and the details on each variant are extensible.
The <code>Unhandled</code> variant should move the error source into a struct so that its type can be hidden.
Otherwise, the code generated errors are already aligned with the goals of this RFC.</p>
<h2 id="approaches-from-other-projects"><a class="header" href="#approaches-from-other-projects">Approaches from other projects</a></h2>
<h3 id="stdioerror"><a class="header" href="#stdioerror"><code>std::io::Error</code></a></h3>
<p>The standard library uses an <code>Error</code> struct with an accompanying <code>ErrorKind</code> enum
for its IO error. Roughly:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
#[non_exhaustive]
pub enum ErrorKind {
    NotFound,
    // ... omitted ...
    Other,
}

#[derive(Debug)]
pub struct Error {
    kind: ErrorKind,
    source: Box&lt;dyn std::error::Error + Send + Sync&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>What this error does well:</p>
<ul>
<li>It is extensible since the <code>ErrorKind</code> is non-exhaustive</li>
<li>It has an <code>Other</code> error type that can be instantiated by users in unit tests,
making it easier to unit test error handling</li>
</ul>
<p>What could be improved:</p>
<ul>
<li>There isn't an ergonomic way to add programmatically accessible error-specific context
to this error in the future</li>
<li>The source error can be downcasted, which could be a trap for backwards compatibility.</li>
</ul>
<h3 id="hyper-10"><a class="header" href="#hyper-10">Hyper 1.0</a></h3>
<p>Hyper has outlined <a href="https://github.com/hyperium/hyper/blob/bd7928f3dd6a8461f0f0fdf7ee0fd95c2f156f88/docs/ROADMAP.md#errors">some problems they want to address with errors</a>
for the coming 1.0 release. To summarize:</p>
<ul>
<li>It's difficult to match on specific errors (Hyper 0.x's <code>Error</code> relies
on <code>is_x</code> methods for error matching rather than enum matching).</li>
<li>Error reporters duplicate information since the hyper 0.x errors include the display of their error sources</li>
<li><code>Error::source()</code> can leak internal dependencies</li>
</ul>
<h2 id="opaque-error-sources"><a class="header" href="#opaque-error-sources">Opaque Error Sources</a></h2>
<p>There is <a href="https://github.com/rust-lang/project-error-handling/issues/53">discussion in the errors working group</a>
about how to avoid leaking internal dependency error types through error source downcasting. One option is to
create an opaque error wrapping new-type that removes the ability to downcast to the other library's error.
This, however, can be circumvented via unsafe code, and also breaks the ability for error reporters to
properly display the error (for example, if the error has backtrace information, that would be
inaccessible to the reporter).</p>
<p>This situation might improve if the nightly <code>request_value</code>/<code>request_ref</code>/<code>provide</code> functions on
<code>std::error::Error</code> are stabilized, since then contextual information needed for including things
such as a backtrace could still be retrieved through the opaque error new-type.</p>
<p>This RFC proposes that error types from other libraries not be directly exposed in the API, but rather,
be exposed indirectly through <code>Error::source</code> as <code>&amp;dyn Error + 'static</code>.</p>
<p>Errors should not require downcasting to be useful. Downcasting the error's source should be
a last resort, and with the understanding that the type could change at a later date with no
compile-time guarantees.</p>
<h2 id="error-proposal"><a class="header" href="#error-proposal">Error Proposal</a></h2>
<p>Taking a customer's perspective, there are two broad categories of errors:</p>
<ol>
<li><strong>Actionable:</strong> Errors that can/should influence program flow; where it's useful to
do different work based on additional error context or error variant information</li>
<li><strong>Informative:</strong> Errors that inform that something went wrong, but where
it's not useful to match on the error to change program flow</li>
</ol>
<p>This RFC proposes that a consistent pattern be introduced to cover these two use cases for
all errors in the public API for the Rust runtime crates and generated client crates.</p>
<h3 id="actionable-error-pattern"><a class="header" href="#actionable-error-pattern">Actionable error pattern</a></h3>
<p>Actionable errors are represented as enums. If an error variant has an error source or additional contextual
information, it must use a separate context struct that is referenced via tuple in the enum. For example:</p>
<pre><code class="language-rust ignore">// Good: new error types can be added in the future
#[non_exhaustive]
pub enum Error {
    // Good: This is exhaustive and uses a tuple, but its sole member is an extensible struct with private fields
    VariantA(VariantA),

    // Bad: The fields are directly exposed and can't have accessor methods. The error
    // source type also can't be changed at a later date since.
    #[non_exhaustive]
    VariantB {
        some_additional_info: u32,
        source: AnotherError // AnotherError is from this crate
    },

    // Bad: There's no way to add additional contextual information to this error in the future, even
    // though it is non-exhaustive. Changing it to a tuple or struct later leads to compile errors in existing
    // match statements.
    #[non_exhaustive]
    VariantC,

    // Bad: Not extensible if additional context is added later (unless that context can be added to `AnotherError`)
    #[non_exhaustive]
    VariantD(AnotherError),

    // Bad: Not extensible. If new context is added later (for example, a second endpoint), there's no way to name it.
    #[non_exhaustive]
    VariantE(Endpoint, AnotherError),

    // Bad: Exposes another library's error type in the public API,
    // which makes upgrading or replacing that library a breaking change
    #[non_exhaustive]
    VariantF {
        source: http::uri::InvalidUri
    },

    // Bad: The error source type is public, and even though its a boxed error, it won't
    // be possible to change it to an opaque error type later (for example, if/when
    // opaque errors become practical due to standard library stabilizations).
    #[non_exhaustive]
    VariantG {
        source: Box&lt;dyn Error + Send + Sync + 'static&gt;,
    }
}

pub struct VariantA {
    some_field: u32,
    // This is private, so it's fine to reference the external library's error type
    source: http::uri::InvalidUri
}

impl VariantA {
    fn some_field(&amp;self) -&gt; u32 {
        self.some_field
    }
}</code></pre>
<p>Error variants that contain a source must return it from the <code>Error::source</code> method.
The <code>source</code> implementation <em>should not</em> use the catch all (<code>_</code>) match arm, as this makes it easy to miss
adding a new error variant's source at a later date.</p>
<p>The error <code>Display</code> implementation <em>must not</em> include the source in its output:</p>
<pre><code class="language-rust ignore">// Good
impl fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Self::VariantA =&gt; write!(f, "variant a"),
            Self::VariantB { some_additional_info, .. } =&gt; write!(f, "variant b ({some_additional_info})"),
            // ... and so on
        }
    }
}

// Bad
impl fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        match self {
            Self::VariantA =&gt; write!(f, "variant a"),
            // Bad: includes the source in the `Display` output, which leads to duplicate error information
            Self::VariantB { some_additional_info, source } =&gt; write!(f, "variant b ({some_additional_info}): {source}"),
            // ... and so on
        }
    }
}</code></pre>
<h3 id="informative-error-pattern"><a class="header" href="#informative-error-pattern">Informative error pattern</a></h3>
<p>Informative errors must be represented as structs. If error messaging changes based on an underlying cause, then a
private error kind enum can be used internally for this purpose. For example:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct InformativeError {
    some_additional_info: u32,
    source: AnotherError,
}

impl fmt::Display for InformativeError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "some informative message with {}", self.some_additional_info)
    }
}

impl Error for InformativeError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {
        Some(&amp;self.source)
    }
}</code></pre>
<p>In general, informative errors should be referenced by variants in actionable errors since they cannot be converted
to actionable errors at a later date without a breaking change. This is not a hard rule, however. Use your best judgement
for the situation.</p>
<h3 id="displaying-full-error-context"><a class="header" href="#displaying-full-error-context">Displaying full error context</a></h3>
<p>In code where errors are logged rather than returned to the customer, the full error source chain
must be displayed. This will be made easy by placing a <code>DisplayErrorContext</code> struct in <code>aws-smithy-types</code> that
is used as a wrapper to get the better error formatting:</p>
<pre><code class="language-rust ignore">tracing::warn!(err = %DisplayErrorContext(err), "some message");</code></pre>
<p>This might be implemented as follows:</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
pub struct DisplayErrorContext&lt;E: Error&gt;(pub E);

impl&lt;E: Error&gt; fmt::Display for DisplayErrorContext&lt;E&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write_err(f, &amp;self.0)?;
        // Also add a debug version of the error at the end
        write!(f, " ({:?})", self)
    }
}

fn write_err(f: &amp;mut fmt::Formatter&lt;'_&gt;, err: &amp;dyn Error) -&gt; fmt::Result {
    write!(f, "{}", err)?;
    if let Some(source) = err.source() {
        write!(f, ": ")?;
        write_err(f, source)?;
    }
    Ok(())
}</code></pre>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Update every struct/enum that implements <code>Error</code> in all the non-server Rust runtime crates</li>
<li><input disabled="" type="checkbox" checked=""/>
Hide error source type in <code>Unhandled</code> variant in code generated errors</li>
<li><input disabled="" type="checkbox" checked=""/>
Remove <code>Clone</code> from <code>ProfileParseError</code> and any others that have it</li>
</ul>
<h2 id="error-code-review-checklist"><a class="header" href="#error-code-review-checklist">Error Code Review Checklist</a></h2>
<p>This is a checklist meant to aid code review of new errors:</p>
<ul>
<li><input disabled="" type="checkbox"/>
The error fits either the actionable or informative pattern</li>
<li><input disabled="" type="checkbox"/>
If the error is informative, it's clear that it will never be expanded with additional variants in the future</li>
<li><input disabled="" type="checkbox"/>
The <code>Display</code> impl does not write the error source to the formatter</li>
<li><input disabled="" type="checkbox"/>
The catch all <code>_</code> match arm is not used in the <code>Display</code> or <code>Error::source</code> implementations</li>
<li><input disabled="" type="checkbox"/>
Error types from external libraries are not exposed in the public API</li>
<li><input disabled="" type="checkbox"/>
Error enums are <code>#[non_exhaustive]</code></li>
<li><input disabled="" type="checkbox"/>
Error enum variants that don't have a separate error context struct are <code>#[non_exhaustive]</code></li>
<li><input disabled="" type="checkbox"/>
Error context is exposed via accessors rather than by public fields</li>
<li><input disabled="" type="checkbox"/>
Actionable errors and their context structs are in an <code>error</code> submodule for any given module. They are not mixed with other non-error code</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rfcs/rfc0021_dependency_versions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rfcs/rfc0023_refine_builder.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rfcs/rfc0021_dependency_versions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rfcs/rfc0023_refine_builder.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../static/mermaid.min.js"></script>
        <script src="../static/mermaid-init.js"></script>


    </div>
    </body>
</html>
