<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Anatomy of a Service - Smithy Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">4.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">4.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">4.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">4.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">4.4.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../client/overview.html"><strong aria-hidden="true">5.</strong> Client</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../client/orchestrator.html"><strong aria-hidden="true">5.1.</strong> What is the 'orchestrator' and why does it exist?</a></li><li class="chapter-item expanded "><a href="../client/identity_and_auth.html"><strong aria-hidden="true">5.2.</strong> Identity and Auth</a></li><li class="chapter-item expanded "><a href="../client/detailed_error_explanations.html"><strong aria-hidden="true">5.3.</strong> Detailed error explanations</a></li></ol></li><li class="chapter-item expanded "><a href="../server/overview.html"><strong aria-hidden="true">6.</strong> Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../server/middleware.html"><strong aria-hidden="true">6.1.</strong> Middleware</a></li><li class="chapter-item expanded "><a href="../server/instrumentation.html"><strong aria-hidden="true">6.2.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="../server/from_parts.html"><strong aria-hidden="true">6.3.</strong> Accessing Un-modelled Data</a></li><li class="chapter-item expanded "><a href="../server/anatomy.html" class="active"><strong aria-hidden="true">6.4.</strong> The Anatomy of a Service</a></li><li class="chapter-item expanded "><a href="../server/code_generation.html"><strong aria-hidden="true">6.5.</strong> Generating Common Service Code</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">7.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">7.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html"><strong aria-hidden="true">7.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">7.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">7.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">7.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">7.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">7.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">7.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">7.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">7.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">7.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">7.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">7.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">7.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">7.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">7.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">7.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">7.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">7.19.</strong> RFC-0019: Event Streams Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0020_service_builder.html"><strong aria-hidden="true">7.20.</strong> RFC-0020: Service Builder Improvements</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0021_dependency_versions.html"><strong aria-hidden="true">7.21.</strong> RFC-0021: Dependency Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0022_error_context_and_compatibility.html"><strong aria-hidden="true">7.22.</strong> RFC-0022: Error Context and Compatibility</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0023_refine_builder.html"><strong aria-hidden="true">7.23.</strong> RFC-0023: Evolving the new service builder API</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0024_request_id.html"><strong aria-hidden="true">7.24.</strong> RFC-0024: RequestID</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0025_constraint_traits.html"><strong aria-hidden="true">7.25.</strong> RFC-0025: Constraint traits</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0026_client_crate_organization.html"><strong aria-hidden="true">7.26.</strong> RFC-0026: Client Crate Organization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0027_endpoints_20.html"><strong aria-hidden="true">7.27.</strong> RFC-0027: Endpoints 2.0</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0028_sdk_credential_cache_type_safety.html"><strong aria-hidden="true">7.28.</strong> RFC-0028: SDK Credential Cache Type Safety</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0029_new_home_for_cred_types.html"><strong aria-hidden="true">7.29.</strong> RFC-0029: Finding New Home for Credential Types</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0030_serialization_and_deserialization.html"><strong aria-hidden="true">7.30.</strong> RFC-0030: Serialization And Deserialization</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0031_providing_fallback_credentials_on_timeout.html"><strong aria-hidden="true">7.31.</strong> RFC-0031: Providing Fallback Credentials on Timeout</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0032_better_constraint_violations.html"><strong aria-hidden="true">7.32.</strong> RFC-0032: Better Constraint Violations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0033_improve_sdk_request_id_access.html"><strong aria-hidden="true">7.33.</strong> RFC-0033: Improving access to request IDs in SDK clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0034_smithy_orchestrator.html"><strong aria-hidden="true">7.34.</strong> RFC-0034: Smithy Orchestrator</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0035_collection_defaults.html"><strong aria-hidden="true">7.35.</strong> RFC-0035: Collection Defaults</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0036_http_dep_elimination.html"><strong aria-hidden="true">7.36.</strong> RFC-0036: HTTP Dependency Exposure</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0037_http_wrapper.html"><strong aria-hidden="true">7.37.</strong> RFC-0037: The HTTP Wrapper</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0038_retry_classifier_customization.html"><strong aria-hidden="true">7.38.</strong> RFC-0038: User-configurable retry classification</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0039_forward_compatible_errors.html"><strong aria-hidden="true">7.39.</strong> RFC-0039: Forward Compatible Errors</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0040_behavior_versions.html"><strong aria-hidden="true">7.40.</strong> RFC-0040: Behavior Versions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0041_improve_client_error_ergonomics.html"><strong aria-hidden="true">7.41.</strong> RFC-0041: Improve client error ergonomics</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0042_file_per_change_changelog.html"><strong aria-hidden="true">7.42.</strong> RFC-0042: File-per-change changelog</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0043_identity_cache_partitions.html"><strong aria-hidden="true">7.43.</strong> RFC-0043: Identity Cache Partitions</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0044_env_defined_service_config.html"><strong aria-hidden="true">7.44.</strong> RFC-0044: Environment-defined service configuration</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">8.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">8.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smithy Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-anatomy-of-a-service"><a class="header" href="#the-anatomy-of-a-service">The Anatomy of a Service</a></h1>
<p>What is <a href="https://awslabs.github.io/smithy/2.0/index.html">Smithy</a>? At a high-level, it's a grammar for specifying services while leaving the business logic undefined. A <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#service">Smithy Service</a> specifies a collection of function signatures in the form of <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#operation">Operations</a>, their purpose is to encapsulate business logic. A Smithy implementation should, for each Smithy Service, provide a builder, which accepts functions conforming to said signatures, and returns a service subject to the semantics specified by the model.</p>
<p>This survey is disinterested in the actual Kotlin implementation of the code generator, and instead focuses on the structure of the generated Rust code and how it relates to the Smithy model. The intended audience is new contributors and users interested in internal details.</p>
<p>During the survey we will use the <a href="https://github.com/smithy-lang/smithy-rs/blob/main/codegen-core/common-test-models/pokemon.smithy"><code>pokemon.smithy</code></a> model as a reference:</p>
<pre><code class="language-smithy">/// A Pokémon species forms the basis for at least one Pokémon.
@title("Pokémon Species")
resource PokemonSpecies {
    identifiers: {
        name: String
    },
    read: GetPokemonSpecies,
}

/// A users current Pokémon storage.
resource Storage {
    identifiers: {
        user: String
    },
    read: GetStorage,
}

/// The Pokémon Service allows you to retrieve information about Pokémon species.
@title("Pokémon Service")
@restJson1
service PokemonService {
    version: "2021-12-01",
    resources: [PokemonSpecies, Storage],
    operations: [
        GetServerStatistics,
        DoNothing,
        CapturePokemon,
        CheckHealth
    ],
}
</code></pre>
<p>Smithy Rust will use this model to produce the following API:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate pokemon_service_server_sdk;
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::protocol::rest_json_1::{RestJson1, router::RestRouter};
</span><span class="boring">use aws_smithy_http_server::routing::{Route, RoutingService};
</span><span class="boring">use pokemon_service_server_sdk::{input::*, output::*, error::*, operation_shape::*, PokemonServiceConfig, PokemonService};
</span>// A handler for the `GetPokemonSpecies` operation (the `PokemonSpecies` resource).
async fn get_pokemon_species(input: GetPokemonSpeciesInput) -&gt; Result&lt;GetPokemonSpeciesOutput, GetPokemonSpeciesError&gt; {
    todo!()
}

let config = PokemonServiceConfig::builder().build();

// Use the service builder to create `PokemonService`.
let pokemon_service = PokemonService::builder(config)
    // Pass the handler directly to the service builder...
    .get_pokemon_species(get_pokemon_species)
    /* other operation setters */
    .build()
    .expect("failed to create an instance of the Pokémon service");
<span class="boring">let pokemon_service: PokemonService&lt;RoutingService&lt;RestRouter&lt;Route&gt;, RestJson1&gt;&gt;  = pokemon_service;
</span><span class="boring">}</span></code></pre></pre>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<p>A <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#operation">Smithy Operation</a> specifies the input, output, and possible errors of an API operation. One might characterize a Smithy Operation as syntax for specifying a function type.</p>
<p>We represent this in Rust using the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/trait.OperationShape.html"><code>OperationShape</code></a> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::shape_id::ShapeId;
</span>pub trait OperationShape {
    /// The name of the operation.
    const ID: ShapeId;

    /// The operation input.
    type Input;
    /// The operation output.
    type Output;
    /// The operation error. [`Infallible`](std::convert::Infallible) in the case where no error
    /// exists.
    type Error;
}
<span class="boring">use aws_smithy_http_server::operation::OperationShape as OpS;
</span><span class="boring">impl&lt;T: OpS&gt; OperationShape for T {
</span><span class="boring">  const ID: ShapeId = &lt;T as OpS&gt;::ID;
</span><span class="boring">  type Input = &lt;T as OpS&gt;::Input;
</span><span class="boring">  type Output = &lt;T as OpS&gt;::Output;
</span><span class="boring">  type Error = &lt;T as OpS&gt;::Error;
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>For each Smithy Operation shape,</p>
<pre><code class="language-smithy">/// Retrieve information about a Pokémon species.
@readonly
@http(uri: "/pokemon-species/{name}", method: "GET")
operation GetPokemonSpecies {
    input: GetPokemonSpeciesInput,
    output: GetPokemonSpeciesOutput,
    errors: [ResourceNotFoundException],
}
</code></pre>
<p>the following implementation is generated</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate pokemon_service_server_sdk;
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::{operation::OperationShape, shape_id::ShapeId};
</span><span class="boring">use pokemon_service_server_sdk::{input::*, output::*, error::*};
</span>/// Retrieve information about a Pokémon species.
pub struct GetPokemonSpecies;

impl OperationShape for GetPokemonSpecies {
    const ID: ShapeId = ShapeId::new("com.aws.example#GetPokemonSpecies", "com.aws.example", "GetPokemonSpecies");

    type Input = GetPokemonSpeciesInput;
    type Output = GetPokemonSpeciesOutput;
    type Error = GetPokemonSpeciesError;
}
<span class="boring">}</span></code></pre></pre>
<p>where <code>GetPokemonSpeciesInput</code>, <code>GetPokemonSpeciesOutput</code> are both generated from the Smithy structures and <code>GetPokemonSpeciesError</code> is an enum generated from the <code>errors: [ResourceNotFoundException]</code>.</p>
<p>Note that the <code>GetPokemonSpecies</code> marker structure is a zero-sized type (ZST), and therefore does not exist at runtime - it is a way to attach operation-specific data on an entity within the type system.</p>
<p>The following nomenclature will aid us in our survey. We describe a <code>tower::Service</code> as a "model service" if its request and response are Smithy structures, as defined by the <code>OperationShape</code> trait - the <code>GetPokemonSpeciesInput</code>, <code>GetPokemonSpeciesOutput</code>, and <code>GetPokemonSpeciesError</code> described above. Similarly, we describe a <code>tower::Service</code> as a "HTTP service" if its request and response are <a href="https://github.com/hyperium/http"><code>http</code></a> structures - <code>http::Request</code> and <code>http::Response</code>.</p>
<p>The constructors exist on the marker ZSTs as an extension trait to <code>OperationShape</code>, namely <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/trait.OperationShapeExt.html"><code>OperationShapeExt</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::operation::*;
</span>/// An extension trait over [`OperationShape`].
pub trait OperationShapeExt: OperationShape {
    /// Creates a new [`Service`] for well-formed [`Handler`]s.
    fn from_handler&lt;H, Exts&gt;(handler: H) -&gt; IntoService&lt;Self, H&gt;
    where
        H: Handler&lt;Self, Exts&gt;,
        Self: Sized;

    /// Creates a new [`Service`] for well-formed [`Service`](tower::Service)s.
    fn from_service&lt;S, Exts&gt;(svc: S) -&gt; Normalize&lt;Self, S&gt;
    where
        S: OperationService&lt;Self, Exts&gt;,
        Self: Sized;
}
<span class="boring">use aws_smithy_http_server::operation::OperationShapeExt as OpS;
</span><span class="boring">impl&lt;T: OpS&gt; OperationShapeExt for T {
</span><span class="boring">  fn from_handler&lt;H, Exts&gt;(handler: H) -&gt; IntoService&lt;Self, H&gt; where H: Handler&lt;Self, Exts&gt;, Self: Sized { &lt;T as OpS&gt;::from_handler(handler) }
</span><span class="boring">  fn from_service&lt;S, Exts&gt;(svc: S) -&gt; Normalize&lt;Self, S&gt; where S: OperationService&lt;Self, Exts&gt;, Self: Sized { &lt;T as OpS&gt;::from_service(svc) }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Observe that there are two constructors provided: <code>from_handler</code> which takes a <code>H: Handler</code> and <code>from_service</code> which takes a <code>S: OperationService</code>. In both cases <code>Self</code> is passed as a parameter to the traits - this constrains <code>handler: H</code> and <code>svc: S</code> to the signature given by the implementation of <code>OperationShape</code> on <code>Self</code>.</p>
<p>The <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/trait.Handler.html"><code>Handler</code></a> and <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/trait.OperationService.html"><code>OperationService</code></a> both serve a similar purpose - they provide a common interface for converting to a model service <code>S</code>.</p>
<ul>
<li>The <code>Handler&lt;GetPokemonSpecies&gt;</code> trait covers all async functions taking <code>GetPokemonSpeciesInput</code> and asynchronously returning a <code>Result&lt;GetPokemonSpeciesOutput, GetPokemonSpeciesError&gt;</code>.</li>
<li>The <code>OperationService&lt;GetPokemonSpecies&gt;</code> trait covers all <code>tower::Service</code>s with request <code>GetPokemonSpeciesInput</code>, response <code>GetPokemonSpeciesOutput</code> and error <code>GetPokemonSpeciesOutput</code>.</li>
</ul>
<p>The <code>from_handler</code> constructor is used in the following way:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate pokemon_service_server_sdk;
</span><span class="boring">extern crate aws_smithy_http_server;
</span>use pokemon_service_server_sdk::{
    input::GetPokemonSpeciesInput,
    output::GetPokemonSpeciesOutput,
    error::GetPokemonSpeciesError,
    operation_shape::GetPokemonSpecies
};
use aws_smithy_http_server::operation::OperationShapeExt;

async fn get_pokemon_service(input: GetPokemonSpeciesInput) -&gt; Result&lt;GetPokemonSpeciesOutput, GetPokemonSpeciesError&gt; {
    todo!()
}

let operation = GetPokemonSpecies::from_handler(get_pokemon_service);
<span class="boring">}</span></code></pre></pre>
<p>Alternatively, <code>from_service</code> constructor:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate pokemon_service_server_sdk;
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">extern crate tower;
</span>use pokemon_service_server_sdk::{
    input::GetPokemonSpeciesInput,
    output::GetPokemonSpeciesOutput,
    error::GetPokemonSpeciesError,
    operation_shape::GetPokemonSpecies
};
use aws_smithy_http_server::operation::OperationShapeExt;
use std::task::{Context, Poll};
use tower::Service;

struct Svc {
    /* ... */
}

impl Service&lt;GetPokemonSpeciesInput&gt; for Svc {
    type Response = GetPokemonSpeciesOutput;
    type Error = GetPokemonSpeciesError;
    type Future = /* Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt; */
<span class="boring">    std::future::Ready&lt;Result&lt;Self::Response, Self::Error&gt;&gt;;
</span>
    fn poll_ready(&amp;mut self, ctx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        todo!()
    }

    fn call(&amp;mut self, input: GetPokemonSpeciesInput) -&gt; Self::Future {
        todo!()
    }
}

let svc: Svc = Svc { /* ... */ };
let operation = GetPokemonSpecies::from_service(svc);
<span class="boring">}</span></code></pre></pre>
<p>To summarize a <em>model service</em> constructed can be constructed from a <code>Handler</code> or a <code>OperationService</code> subject to the constraints of an <code>OperationShape</code>. More detailed information on these conversions is provided in the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/index.html">Handler and OperationService section</a> Rust docs.</p>
<h2 id="serialization-and-deserialization"><a class="header" href="#serialization-and-deserialization">Serialization and Deserialization</a></h2>
<p>A <a href="https://awslabs.github.io/smithy/2.0/spec/protocol-traits.html#serialization-and-protocol-traits">Smithy protocol</a> specifies the serialization/deserialization scheme - how a HTTP request is transformed into a modelled input and a modelled output to a HTTP response. The is formalized using the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/request/trait.FromRequest.html"><code>FromRequest</code></a> and <a href="https://github.com/smithy-lang/smithy-rs/blob/4c5cbc39384f0d949d7693eb87b5853fe72629cd/rust-runtime/aws-smithy-http-server/src/response.rs#L40-L44"><code>IntoResponse</code></a> traits:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">extern crate http;
</span><span class="boring">use aws_smithy_http_server::body::BoxBody;
</span><span class="boring">use std::future::Future;
</span>/// Provides a protocol aware extraction from a [`Request`]. This consumes the
/// [`Request`], in contrast to [`FromParts`].
pub trait FromRequest&lt;Protocol, B&gt;: Sized {
    type Rejection: IntoResponse&lt;Protocol&gt;;
    type Future: Future&lt;Output = Result&lt;Self, Self::Rejection&gt;&gt;;

    /// Extracts `self` from a [`Request`] asynchronously.
    fn from_request(request: http::Request&lt;B&gt;) -&gt; Self::Future;
}

/// A protocol aware function taking `self` to [`http::Response`].
pub trait IntoResponse&lt;Protocol&gt; {
    /// Performs a conversion into a [`http::Response`].
    fn into_response(self) -&gt; http::Response&lt;BoxBody&gt;;
}
<span class="boring">use aws_smithy_http_server::request::FromRequest as FR;
</span><span class="boring">impl&lt;P, B, T: FR&lt;P, B&gt;&gt; FromRequest&lt;P, B&gt; for T {
</span><span class="boring">  type Rejection = &lt;T as FR&lt;P, B&gt;&gt;::Rejection;
</span><span class="boring">  type Future = &lt;T as FR&lt;P, B&gt;&gt;::Future;
</span><span class="boring">  fn from_request(request: http::Request&lt;B&gt;) -&gt; Self::Future {
</span><span class="boring">      &lt;T as FR&lt;P, B&gt;&gt;::from_request(request)
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">use aws_smithy_http_server::response::IntoResponse as IR;
</span><span class="boring">impl&lt;P, T: IR&lt;P&gt;&gt; IntoResponse&lt;P&gt; for T {
</span><span class="boring">  fn into_response(self) -&gt; http::Response&lt;BoxBody&gt; { &lt;T as IR&lt;P&gt;&gt;::into_response(self) }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Note that both traits are parameterized by <code>Protocol</code>. These <a href="https://awslabs.github.io/smithy/2.0/aws/protocols/index.html">protocols</a> exist as ZST marker structs:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::protocol::{
</span><span class="boring">  aws_json_10::AwsJson1_0 as _,
</span><span class="boring">  aws_json_11::AwsJson1_1 as _,
</span><span class="boring">  rest_json_1::RestJson1 as _,
</span><span class="boring">  rest_xml::RestXml as _,
</span><span class="boring">};
</span>/// [AWS REST JSON 1.0 Protocol](https://awslabs.github.io/smithy/2.0/aws/protocols/aws-restjson1-protocol.html).
pub struct RestJson1;

/// [AWS REST XML Protocol](https://awslabs.github.io/smithy/2.0/aws/protocols/aws-restxml-protocol.html).
pub struct RestXml;

/// [AWS JSON 1.0 Protocol](https://awslabs.github.io/smithy/2.0/aws/protocols/aws-json-1_0-protocol.html).
pub struct AwsJson1_0;

/// [AWS JSON 1.1 Protocol](https://awslabs.github.io/smithy/2.0/aws/protocols/aws-json-1_1-protocol.html).
pub struct AwsJson1_1;
<span class="boring">}</span></code></pre></pre>
<h2 id="upgrading-a-model-service"><a class="header" href="#upgrading-a-model-service">Upgrading a Model Service</a></h2>
<p>We can "upgrade" a model service to a HTTP service using <code>FromRequest</code> and <code>IntoResponse</code> described in the prior section:</p>
<pre class="mermaid">stateDiagram-v2
    direction LR
    HttpService: HTTP Service
    [*] --&gt; from_request: HTTP Request
    state HttpService {
        direction LR
        ModelService: Model Service
        from_request --&gt; ModelService: Model Input
        ModelService --&gt; into_response: Model Output
    }
    into_response --&gt; [*]: HTTP Response
</pre>
<p>This is formalized by the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/operation/struct.Upgrade.html"><code>Upgrade&lt;Protocol, Op, S&gt;</code></a> HTTP service. The <code>tower::Service</code> implementation is approximately:</p>
<pre><code class="language-rust ignore">impl&lt;P, Op, S&gt; Service&lt;http::Request&gt; for Upgrade&lt;P, Op, S&gt;
where
    Input: FromRequest&lt;P, B&gt;,
    S: Service&lt;Input&gt;,
    S::Response: IntoResponse&lt;P&gt;,
    S::Error: IntoResponse&lt;P&gt;,
{
    async fn call(&amp;mut self, request: http::Request) -&gt; http::Response {
        let model_request = match &lt;Op::Input as OperationShape&gt;::from_request(request).await {
            Ok(ok) =&gt; ok,
            Err(err) =&gt; return err.into_response()
        };
        let model_response = self.model_service.call(model_request).await;
        model_response.into_response()
    }
}</code></pre>
<p>When we <code>GetPokemonSpecies::from_handler</code> or <code>GetPokemonSpecies::from_service</code>, the model service produced, <code>S</code>, will meet the constraints above.</p>
<p>There is an associated <code>Plugin</code>, <code>UpgradePlugin</code> which constructs <code>Upgrade</code> from a service.</p>
<p>The upgrade procedure is finalized by the application of the <code>Layer</code> <code>L</code>, referenced in <code>Operation&lt;S, L&gt;</code>. In this way the entire upgrade procedure takes an <code>Operation&lt;S, L&gt;</code> and returns a HTTP service.</p>
<pre class="mermaid">stateDiagram-v2
    direction LR
    [*] --&gt; UpgradePlugin: HTTP Request
    state HttpPlugin {
        state UpgradePlugin {
            direction LR
            [*] --&gt; S: Model Input
            S --&gt; [*] : Model Output
            state ModelPlugin {
                S
            }
        }
    }
    UpgradePlugin --&gt; [*]: HTTP Response
</pre>
<p>Note that the <code>S</code> is specified by logic written, in Rust, by the customer, whereas <code>UpgradePlugin</code> is specified entirely by Smithy model via the protocol, <a href="https://awslabs.github.io/smithy/2.0/spec/http-bindings.html">HTTP bindings</a>, etc.</p>
<h2 id="routers"><a class="header" href="#routers">Routers</a></h2>
<p>Different protocols supported by Smithy enjoy different routing mechanisms, for example, <a href="https://awslabs.github.io/smithy/2.0/aws/protocols/aws-json-1_0-protocol.html#protocol-behaviors">AWS JSON 1.0</a> uses the <code>X-Amz-Target</code> header to select an operation, whereas <a href="https://awslabs.github.io/smithy/2.0/aws/protocols/aws-restxml-protocol.html">AWS REST XML</a> uses the <a href="https://awslabs.github.io/smithy/2.0/spec/http-bindings.html#httplabel-trait">HTTP label trait</a>.</p>
<p>Despite their differences, all routing mechanisms satisfy a common interface. This is formalized using the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/routing/trait.Router.html">Router</a> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">extern crate http;
</span>/// An interface for retrieving an inner [`Service`] given a [`http::Request`].
pub trait Router&lt;B&gt; {
    type Service;
    type Error;

    /// Matches a [`http::Request`] to a target [`Service`].
    fn match_route(&amp;self, request: &amp;http::Request&lt;B&gt;) -&gt; Result&lt;Self::Service, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>which provides the ability to determine an inner HTTP service from a collection using a <code>&amp;http::Request</code>.</p>
<p>Types which implement the <code>Router</code> trait are converted to a HTTP service via the <code>RoutingService</code> struct:</p>
<pre><code class="language-rust ignore">/// A [`Service`] using a [`Router`] `R` to redirect messages to specific routes.
///
/// The `Protocol` parameter is used to determine the serialization of errors.
pub struct RoutingService&lt;R, Protocol&gt; {
    router: R,
    _protocol: PhantomData&lt;Protocol&gt;,
}

impl&lt;R, P&gt; Service&lt;http::Request&gt; for RoutingService&lt;R, P&gt;
where
    R: Router&lt;B&gt;,
    R::Service: Service&lt;http::Request, Response = http::Response&gt;,
    R::Error: IntoResponse&lt;P&gt; + Error,
{
    type Response = http::Response;
    type Error = /* implementation detail */;

    async fn call(&amp;mut self, req: http::Request&lt;B&gt;) -&gt; Result&lt;Self::Response, Self::Error&gt; {
        match self.router.match_route(&amp;req) {
            // Successfully routed, use the routes `Service::call`.
            Ok(ok) =&gt; ok.oneshot(req).await,
            // Failed to route, use the `R::Error`s `IntoResponse&lt;P&gt;`.
            Err(error) =&gt; {
                debug!(%error, "failed to route");
                Err(Box::new(error.into_response()))
            }
        }
    }
}</code></pre>
<p>The <code>RouterService</code> is the final piece necessary to form a functioning composition - it is used to aggregate together the HTTP services, created via the upgrade procedure, into a single HTTP service which can be presented to the customer.</p>
<pre class="mermaid">stateDiagram
state in &lt;&lt;fork&gt;&gt;
    direction LR
    [*] --&gt; in
    state RouterService {
        direction LR
        in --&gt;  ServiceA
        in --&gt; ServiceB
        in --&gt; ServiceC
    }
    ServiceA --&gt; [*]
    ServiceB --&gt; [*]
    ServiceC --&gt; [*]
</pre>
<h2 id="plugins"><a class="header" href="#plugins">Plugins</a></h2>
<!-- TODO(missing_doc): Link to "Write a Plugin" documentation -->
<p>A <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/plugin/trait.Plugin.html"><code>Plugin</code></a> is a
[<code>tower::Layer</code>] with two extra type parameters, <code>Service</code> and <code>Operation</code>, corresponding to <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#service">Smithy Service</a> and <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#operation">Smithy Operation</a>. This allows the middleware to be
parameterized them and change behavior depending on the context in which it's applied.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span>pub trait Plugin&lt;Service, Operation, T&gt; {
    type Output;

    fn apply(&amp;self, input: T) -&gt; Self::Output;
}
<span class="boring">use aws_smithy_http_server::plugin::Plugin as Pl;
</span><span class="boring">impl&lt;Ser, Op, T, U: Pl&lt;Ser, Op, T&gt;&gt; Plugin&lt;Ser, Op, T&gt; for U {
</span><span class="boring">  type Output = &lt;U as Pl&lt;Ser, Op, T&gt;&gt;::Output;
</span><span class="boring">  fn apply(&amp;self, input: T) -&gt; Self::Output { &lt;U as Pl&lt;Ser, Op, T&gt;&gt;::apply(self, input) }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>An example <code>Plugin</code> implementation can be found in <a href="https://github.com/smithy-lang/smithy-rs/blob/main/examples/pokemon-service/src/plugin.rs">/examples/pokemon-service/src/plugin.rs</a>.</p>
<p>Plugins can be applied in two places:</p>
<ul>
<li>HTTP plugins, which are applied pre-deserialization/post-serialization, acting on HTTP requests/responses.</li>
<li>Model plugins, which are applied post-deserialization/pre-serialization, acting on model inputs/outputs/errors.</li>
</ul>
<pre class="mermaid">stateDiagram-v2
    direction LR
    [*] --&gt; S: HTTP Request
    state HttpPlugin {
        state UpgradePlugin {
            state ModelPlugin {
                S
            }
        }
    }
    S --&gt; [*]: HTTP Response
</pre>
<p>The service builder API requires plugins to be specified upfront - they must be
registered in the config object, which is passed as an argument to <code>builder</code>.
Plugins cannot be modified afterwards.</p>
<p>You might find yourself wanting to apply <em>multiple</em> plugins to your service.
This can be accommodated via [<code>HttpPlugins</code>] and [<code>ModelPlugins</code>].</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span>use aws_smithy_http_server::plugin::HttpPlugins;
<span class="boring">use aws_smithy_http_server::plugin::IdentityPlugin as LoggingPlugin;
</span><span class="boring">use aws_smithy_http_server::plugin::IdentityPlugin as MetricsPlugin;
</span>
let http_plugins = HttpPlugins::new().push(LoggingPlugin).push(MetricsPlugin);
<span class="boring">}</span></code></pre></pre>
<p>The plugins' runtime logic is executed in registration order.
In the example above, <code>LoggingPlugin</code> would run first, while <code>MetricsPlugin</code> is executed last.</p>
<p>If you are vending a plugin, you can leverage <code>HttpPlugins</code> or <code>ModelPlugins</code> as an extension point: you can add custom methods to it using an extension trait.
For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span>use aws_smithy_http_server::plugin::{HttpPlugins, PluginStack};
<span class="boring">use aws_smithy_http_server::plugin::IdentityPlugin as LoggingPlugin;
</span><span class="boring">use aws_smithy_http_server::plugin::IdentityPlugin as AuthPlugin;
</span>
pub trait AuthPluginExt&lt;CurrentPlugins&gt; {
    fn with_auth(self) -&gt; HttpPlugins&lt;PluginStack&lt;AuthPlugin, CurrentPlugins&gt;&gt;;
}

impl&lt;CurrentPlugins&gt; AuthPluginExt&lt;CurrentPlugins&gt; for HttpPlugins&lt;CurrentPlugins&gt; {
    fn with_auth(self) -&gt; HttpPlugins&lt;PluginStack&lt;AuthPlugin, CurrentPlugins&gt;&gt; {
        self.push(AuthPlugin)
    }
}

let http_plugins = HttpPlugins::new()
    .push(LoggingPlugin)
    // Our custom method!
    .with_auth();
<span class="boring">}</span></code></pre></pre>
<h2 id="builders"><a class="header" href="#builders">Builders</a></h2>
<p>The service builder is the primary public API, generated for every <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html">Smithy Service</a>.
At a high-level, the service builder takes as input a function for each Smithy Operation and returns a single HTTP service. The signature of each function, also known as <em>handlers</em>, must match the constraints of the corresponding Smithy model.</p>
<p>You can create an instance of a service builder by calling <code>builder</code> on the corresponding service struct.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::routing::Route;
</span>/// The service builder for [`PokemonService`].
///
/// Constructed via [`PokemonService::builder`].
pub struct PokemonServiceBuilder&lt;Body, HttpPl, ModelPl&gt; {
    capture_pokemon_operation: Option&lt;Route&lt;Body&gt;&gt;,
    empty_operation: Option&lt;Route&lt;Body&gt;&gt;,
    get_pokemon_species: Option&lt;Route&lt;Body&gt;&gt;,
    get_server_statistics: Option&lt;Route&lt;Body&gt;&gt;,
    get_storage: Option&lt;Route&lt;Body&gt;&gt;,
    health_check_operation: Option&lt;Route&lt;Body&gt;&gt;,
    http_plugin: HttpPl,
    model_plugin: ModelPl,
}
<span class="boring">}</span></code></pre></pre>
<p>The builder has two setter methods for each <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#operation">Smithy Operation</a> in the <a href="https://awslabs.github.io/smithy/2.0/spec/service-types.html#service">Smithy Service</a>:</p>
<pre><code class="language-rust ignore">    pub fn get_pokemon_species&lt;HandlerType, HandlerExtractors, UpgradeExtractors&gt;(self, handler: HandlerType) -&gt; Self
    where
        HandlerType:Handler&lt;GetPokemonSpecies, HandlerExtractors&gt;,

        ModelPl: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            IntoService&lt;GetPokemonSpecies, HandlerType&gt;
        &gt;,
        UpgradePlugin::&lt;UpgradeExtractors&gt;: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            ModelPlugin::Output
        &gt;,
        HttpPl: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            UpgradePlugin::&lt;UpgradeExtractors&gt;::Output
        &gt;,
    {
        let svc = GetPokemonSpecies::from_handler(handler);
        let svc = self.model_plugin.apply(svc);
        let svc = UpgradePlugin::&lt;UpgradeExtractors&gt;::new()
            .apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.get_pokemon_species_custom(svc)
    }

    pub fn get_pokemon_species_service&lt;S, ServiceExtractors, UpgradeExtractors&gt;(self, service: S) -&gt; Self
    where
        S: OperationService&lt;GetPokemonSpecies, ServiceExtractors&gt;,

        ModelPl: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            Normalize&lt;GetPokemonSpecies, S&gt;
        &gt;,
        UpgradePlugin::&lt;UpgradeExtractors&gt;: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            ModelPlugin::Output
        &gt;,
        HttpPl: Plugin&lt;
            PokemonService,
            GetPokemonSpecies,
            UpgradePlugin::&lt;UpgradeExtractors&gt;::Output
        &gt;,
    {
        let svc = GetPokemonSpecies::from_service(service);
        let svc = self.model_plugin.apply(svc);
        let svc = UpgradePlugin::&lt;UpgradeExtractors&gt;::new().apply(svc);
        let svc = self.http_plugin.apply(svc);
        self.get_pokemon_species_custom(svc)
    }

    pub fn get_pokemon_species_custom&lt;S&gt;(mut self, svc: S) -&gt; Self
    where
        S: Service&lt;Request&lt;Body&gt;, Response = Response&lt;BoxBody&gt;, Error = Infallible&gt;,
    {
        self.get_pokemon_species = Some(Route::new(svc));
        self
    }</code></pre>
<p>Handlers and operations are upgraded to a <a href="https://github.com/smithy-lang/smithy-rs/blob/4c5cbc39384f0d949d7693eb87b5853fe72629cd/rust-runtime/aws-smithy-http-server/src/routing/route.rs#L49-L52"><code>Route</code></a> as soon as they are registered against the service builder. You can think of <code>Route</code> as a boxing layer in disguise.</p>
<p>You can transform a builder instance into a complete service (<code>PokemonService</code>) using one of the following methods:</p>
<ul>
<li><code>build</code>. The transformation fails if one or more operations do not have a registered handler;</li>
<li><code>build_unchecked</code>. The transformation never fails, but we return <code>500</code>s for all operations that do not have a registered handler.</li>
</ul>
<p>Both builder methods take care of:</p>
<ol>
<li>Pair each handler with the routing information for the corresponding operation;</li>
<li>Collect all <code>(routing_info, handler)</code> pairs into a <code>Router</code>;</li>
<li>Transform the <code>Router</code> implementation into a HTTP service via <code>RouterService</code>;</li>
<li>Wrap the <code>RouterService</code> in a newtype given by the service name, <code>PokemonService</code>.</li>
</ol>
<p>The final outcome, an instance of <code>PokemonService</code>, looks roughly like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">use aws_smithy_http_server::{routing::RoutingService, protocol::rest_json_1::{router::RestRouter, RestJson1}};
</span>/// The Pokémon Service allows you to retrieve information about Pokémon species.
#[derive(Clone)]
pub struct PokemonService&lt;S&gt; {
    router: RoutingService&lt;RestRouter&lt;S&gt;, RestJson1&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The following schematic summarizes the composition:</p>
<pre class="mermaid">stateDiagram-v2
    state in &lt;&lt;fork&gt;&gt;
    state &quot;GetPokemonSpecies&quot; as C1
    state &quot;GetStorage&quot; as C2
    state &quot;DoNothing&quot; as C3
    state &quot;...&quot; as C4
    direction LR
    [*] --&gt; in : HTTP Request
    UpgradePlugin --&gt; [*]: HTTP Response
    state PokemonService {
        state RoutingService {
            in --&gt; UpgradePlugin: HTTP Request
            in --&gt; C2: HTTP Request
            in --&gt; C3: HTTP Request
            in --&gt; C4: HTTP Request
            state C1 {
                state HttpPlugin {
                    state UpgradePlugin {
                        direction LR
                        [*] --&gt; S: Model Input
                        S --&gt; [*] : Model Output
                        state ModelPlugin {
                            S
                        }
                    }
                }
            }
            C2
            C3
            C4
        }

    }
    C2 --&gt; [*]: HTTP Response
    C3 --&gt; [*]: HTTP Response
    C4 --&gt; [*]: HTTP Response
</pre>
<h2 id="accessing-unmodelled-data"><a class="header" href="#accessing-unmodelled-data">Accessing Unmodelled Data</a></h2>
<p>An additional omitted detail is that we provide an "escape hatch" allowing <code>Handler</code>s and <code>OperationService</code>s to accept data that isn't modelled. In addition to accepting <code>Op::Input</code> they can accept additional arguments which implement the <a href="https://docs.rs/aws-smithy-http-server/latest/aws_smithy_http_server/request/trait.FromParts.html"><code>FromParts</code></a> trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">extern crate http;
</span><span class="boring">use http::request::Parts;
</span><span class="boring">use aws_smithy_http_server::response::IntoResponse;
</span>/// Provides a protocol aware extraction from a [`Request`]. This borrows the
/// [`Parts`], in contrast to [`FromRequest`].
pub trait FromParts&lt;Protocol&gt;: Sized {
    /// The type of the failures yielded extraction attempts.
    type Rejection: IntoResponse&lt;Protocol&gt;;

    /// Extracts `self` from a [`Parts`] synchronously.
    fn from_parts(parts: &amp;mut Parts) -&gt; Result&lt;Self, Self::Rejection&gt;;
}
<span class="boring">use aws_smithy_http_server::request::FromParts as FP;
</span><span class="boring">impl&lt;P, T: FP&lt;P&gt;&gt; FromParts&lt;P&gt; for T {
</span><span class="boring">  type Rejection = &lt;T as FP&lt;P&gt;&gt;::Rejection;
</span><span class="boring">  fn from_parts(parts: &amp;mut Parts) -&gt; Result&lt;Self, Self::Rejection&gt; { &lt;T as FP&lt;P&gt;&gt;::from_parts(parts) }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>This differs from <code>FromRequest</code> trait, introduced in <a href="#serialization-and-deserialization">Serialization and Deserialization</a>, as it's synchronous and has non-consuming access to <a href="https://docs.rs/http/latest/http/request/struct.Parts.html"><code>Parts</code></a>, rather than the entire <a href="https://docs.rs/http/latest/http/request/struct.Request.html">Request</a>.</p>
<pre><code class="language-rust ignore">pub struct Parts {
    pub method: Method,
    pub uri: Uri,
    pub version: Version,
    pub headers: HeaderMap&lt;HeaderValue&gt;,
    pub extensions: Extensions,
    /* private fields */
}</code></pre>
<p>This is commonly used to access types stored within <a href="https://docs.rs/http/0.2.8/http/struct.Extensions.html"><code>Extensions</code></a> which have been inserted by a middleware. An <code>Extension</code> struct implements <code>FromParts</code> to support this use case:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">extern crate aws_smithy_http_server;
</span><span class="boring">extern crate http;
</span><span class="boring">extern crate thiserror;
</span><span class="boring">use aws_smithy_http_server::{body::BoxBody, request::FromParts, response::IntoResponse};
</span><span class="boring">use http::status::StatusCode;
</span><span class="boring">use thiserror::Error;
</span><span class="boring">fn empty() -&gt; BoxBody { todo!() }
</span>/// Generic extension type stored in and extracted from [request extensions].
///
/// This is commonly used to share state across handlers.
///
/// If the extension is missing it will reject the request with a `500 Internal
/// Server Error` response.
///
/// [request extensions]: https://docs.rs/http/latest/http/struct.Extensions.html
#[derive(Debug, Clone)]
pub struct Extension&lt;T&gt;(pub T);

impl&lt;Protocol, T&gt; FromParts&lt;Protocol&gt; for Extension&lt;T&gt;
where
    T: Clone + Send + Sync + 'static,
{
    type Rejection = MissingExtension;

    fn from_parts(parts: &amp;mut http::request::Parts) -&gt; Result&lt;Self, Self::Rejection&gt; {
        parts.extensions.remove::&lt;T&gt;().map(Extension).ok_or(MissingExtension)
    }
}

/// The extension has not been added to the [`Request`](http::Request) or has been previously removed.
#[derive(Debug, Error)]
#[error("the `Extension` is not present in the `http::Request`")]
pub struct MissingExtension;

impl&lt;Protocol&gt; IntoResponse&lt;Protocol&gt; for MissingExtension {
    fn into_response(self) -&gt; http::Response&lt;BoxBody&gt; {
        let mut response = http::Response::new(empty());
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../server/from_parts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../server/code_generation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../server/from_parts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../server/code_generation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../static/mermaid.min.js"></script>
        <script src="../static/mermaid-init.js"></script>


    </div>
    </body>
</html>
